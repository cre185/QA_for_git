# Q&A File For Using Git (Git Bash,github...)   
***Created by creeper185 2023.3.27***   

## 上回说到。。  
在能够做到使用git进行基本的上传/下载操作之后 有必要真正了解一下git的各部分构成了  
上次简单的提到了版本库存储文件的三个分区 不过这句话其实并不严格 下面来更具体的说明一下  
首先 暂存区可以被理解为本地仓库 这两个概念是等价的 为什么本地仓库叫做暂存区呢 主要是考虑到本地文件又没有上传到云端 那在别人眼里就等于没有 文件恐怕并不会在这里待上太久  
接下来 所有的仓库 包括暂存区和远程仓库 都是有分支（branch）的 之前的三个分区对应的并不是整个仓库 而是仓库中的一个分支  
我们用一点小小的比喻来了解一下branch这东西  
比如说一个仓库就是一个进程 那么branch分支就是进程中的线程  
上次新建的小仓库里只有一个branch 叫做main（或master） 单线程程序是这样的  
然而有一点也很明显 多线程的程序跑起来更顺畅 带branch的仓库协调起来也更舒服一些  
本文的主题就放在branch上了  
***
## branch初步  
branch毕竟是存在于某个仓库之中的 到某个已有仓库中打开bash  
***
#### 看看你的branch  
还是先说调试用命令 该命令可以查看到当前仓库中的所有分支   
```
git branch
```
注意用命令之前确保自己在某个git仓库目录下  
这里又要问了 不是git仓库直接使用之前说过的`git init`初始化一下不就好了吗  
理想很美好 但新建仓库之后还没结束 还得加入点文件进行第一次commit才行 否则本地的仓库应该是一个空图 连第一个节点都没有 这样的状态是不存在分支的（尽管bash的交互中已经显示了master 但是`git branch`不会输出任何结果的）    
正常情况下输出了一个* master 这代表着目前这个仓库在master分支上 如果你的仓库本来有更多branch的话会全部显示出来 带*并且加绿的为当前分支  
***
#### 新建branch  
```
git branch [branch_name]
```
创建一个branch branch_name写名称  
比如说在你的仓库中输入`git branch test` 然后用`git branch`就能看到你刚创建的分支了  
***  
#### 切换当前分支  
```
git checkout [branch_name]
```
按名称切换到指定分支 现在可以切换到刚创建的分支上 再查看一下情况 能看出切换的行为了  
注意切换走时要确保没有进行什么改动 否则git会认为你忘了提交修改并阻止这次操作 如果修改了就用老办法commit一遍到暂存区  
上面两个命令还可以一起用 使用`git checkout -b [branch_name]`可以直接新建一个分支并切换过去  
***
#### 重命名  
想改个名怎么办 总不能是删掉然后重新建一个吧  
放心 本地仓库相当好操作 与之形成鲜明对比的是远程仓库 传上去了结果错了就很讨厌 所有传到远程仓库的时候一定要多加小心  
```
git branch -m [branch_name] [new_name]
```
这么写可以把一个指定分支改名 其中的branch_name还可以省略 默认的改名对象就是当前分支 因此省略掉就是给当前分支改名  
***
#### 删除分支  
想来想去也没想到创建一个分支是用来干什么的 那就把它删掉好了  
```
git branch -d [branch_name]
```
按名称删除分支 这里可以输入`git branch -d test`  
成功了吗 如果刚刚按顺序复刻了文中操作的话 应该没成功  
其实问题很简单 git不允许删掉目前正位于的分支 这似乎也避免了仓库中完全没有分支这一看起来就会出bug的状态  
重新切换回main/master之后再试一次 这回没毛病了  
***
## branch功能  
同一仓库中的各个分支存储的文件并不相同 这一点毕竟是branch立身的根本  
而分支最高效的一点在于 切换分支的瞬间会把所有文件同步至与目标分支的记录相同  
实操体验一下好了  
***
#### 换来换去  
不妨还用着上次的那个新仓库 经过上次的操作 里面应该只有一个分支  
大可记住这个分支现在的样子 简单粗暴的方法是就把文件夹窗口放在一边 然后新建并切换到一个新分支  
文件夹里没有任何变化 这是因为新建分支都是从当前分支上派生而来的 初始继承了当前分支的所有文件  
下面在文件夹里动点手脚 比如加个`only_in_new_branch.txt`然后往里面写点东西  
接下来commit到分支中 操作完成之后切换回原本的分支  
再去文件夹里看 改动全没了  
如果这是你码了几个小时的论文。。 不过git不会这么傻地吃掉你的作品的 你的一切更改都还在另一个分支中存着呢  
现在在主分支里加点东西 甚至可以和刚刚在另一个分支中创建的文件故意重名（内容写点不一样的 否则改变了都看不出来） 反正这个示例是来看git秀操作的  
还是commit之后再换走 你会发现整个文件夹又回到了刚刚切换至主分支前的样子  
没错 这就是分支的管理方式 互不干扰的工作模式还是相当赏心悦目的 就好比游戏里开了好几个存档一样  
***
#### 不光是sl  
然而游戏里的存档也就能save+load了 不知道各位玩游戏的时候有没有梦想过 能造出一个存档 是之前所有存档的优势的集合  
这个档里有神器级别的装备 那个档里则有精心建构的家园 要是能“我全都要”就好了  
很显然我不会平白无故的扯这些内容（再爱玩游戏的我也不会闲扯的 不会） 各位猜的是对的 git能帮你圆了这个梦想  
```
git merge [target_name]
```
将目标branch合并到当前branch当中 就是这么简单  
这里可以换到主分支上然后把新分支合并过来 大部分合并操作是自动的 但也有例外  
那就是上次我们谈论过的conflict现象 上面建议用重名文件也是想体验一下冲突排解过程  
打开有冲突的文件 修改后重新commit就能完成冲突排解  
就好比合并存档时两把武器选一把更好的 不过此处还可以借鉴两边的代码 也就是说 假设你的两边的武器附魔还不一样 那还可以把更想要的词条挑出来保留  
***
#### 往往在merge之后  
一般的工作过程中merge会是要处理的倒数第二件事 倒数第一件呢  
习惯上创建分支是有原因的 一种可能是和他人一起在仓库提交 全用一个分支会导致成天出现conflict 更何况对方可能改了你要用的库 导致你这里都是完全不知道为什么的bug  
另一种就是自己单开一个分支进行简单的bug修复 新功能追加等测试性质的行动 可以在一个新的branch当中进行 boss战前存个档的道理  
boss战（某个bug）打过了 merge等于存好档了 这时候原来的存档在没必要的时候就可以删掉了  
使用git的时候也不要创建太多的分支 免得整个仓库过于庞大 一方面占地方 另一方面上传下载的过程可就变慢了  
我们刚刚merge了分支 merge操作不会影响到用于合并的分支 原本的分支还原封不动的摆在那里 现在可以放心的删掉它了 ~~过河拆桥直呼内行~~  
***
## merge  
实际上merge操作还是有更多讲究的 上面的例子非常的简单 不过具体的git内部大概实现还是需要了解的 出了各种奇怪的问题能有点思路  
我们说过git把各个版本都管理为一张图 只不过当初我们只有一个branch 图已经退化为表了  
现在我们要看看git的这张图管理的怎么样  
***
#### 图log  
```
git log --graph
```
上面的命令不妨自己试一试 还保持在刚才进行一系列操作的仓库里 能看到一个用简约线条+极致色彩表示的图  
当然不加那个`--graph`参数也是可以输出log的 不过加上能看的更直观一些 我的习惯是加上  
输出的每一条操作都包含几个部分：  
* 某一个版本的编号 以及可能的该版本是哪个分支的最新版本  
* 特殊操作的提示信息 比如merge会提供哪两个版本被合并了  
* 操作发生的时间以及操作用户  
* commit时的备注信息  

如果log无法全部显示 长按下箭头可以向下继续查看 查看完毕后按下q键即可回到命令行环境  
从输出中能够看到之前发生了什么 merge操作把两个节点合为一体了 也就是说merge其实创建了一个新的版本并把原有的两个版本融合了进去  
接下来的过程中可以多使用这个命令  
***  
#### HEAD  
输出中可能还有`HEAD -> [branch_name]`这样的显示 后面是某一分支的名称 那HEAD是什么东西呢  
其实HEAD很好理解 git里有很多版本也即节点 而我们可以在版本间自由地进行切换 HEAD就是指向当前我们所在节点（即当前分支当前版本）的指针  
也正是基于这个指针 git支持方便地回退版本等操作 这些操作下一篇文档再重点说明  
现在只要了解 当使用`git checkout`切换分支时 进行任意commit时 等等操作 HEAD就会指向你想要的版本  
***
#### merge模式  
merge操作的实现实际上有多种模式 如果上面进行过的merge操作输出仔细观察过的话 能看到使用了什么策略  
比如默认应该采用了ort策略 这一策略优化比较完善 2021年成为了git的默认合并策略  
关于更多策略可以查看[这里](https://git-scm.com/docs/merge-strategies)  
这么多策略的存在自然有其意义 很多策略在面对独特情景（比如分支差异很大 或是需要高精确度的合并 甚至是合并多个节点）是非常适配的  
对于git的合并策略实现有兴趣的话参考[此文](https://git-scm.com/docs/merge-strategies) 讲解还算明白  
git还内置了一个小小的语句来输出两个节点的公共祖先 [此处](https://www.unix.com/man-page/linux/1/git-merge-base/)是关于`git merge-base`命令的说明  
不妨进行一个简单的试用 参考你的仓库的log输出 看到仓库目前的图状态 然后选择两个节点  
由于输入大串数字比较费劲 这里输入两个不同指针即可 指针可以用HEAD 还可以用分支名称 每一个分支实际上也是一个指针  
给你的输出是一大串16进制数字 这个就是节点对应的编号了 每个节点的编号仍然在log中查看  
可以自己多创造几个库 进行多次交叉的提交 然后调用该命令测试测试  
***
## remote branch  
远程库的操作就比本地的版本库费劲多了 这里的费劲是操作方面的  
仍然按照上面的顺序 这回看看远程库中的branch如何管理  
***
#### 先看看remote  
```
git remote
```
仍然是简单的调试用命令 当你记不住各种操作的命令时 优先记住这些输出直观信息的命令 很有用 剩下的不行可以到文档里找  
输出本地添加的所有远程仓库  
***
#### 看看remote的branch  
`git branch -a`命令会输出所有分支的信息 较上面就是简单的加上-a参数即可  
远程仓库中的分支显示为红色 如果这个分支在本地有同步版本则会有专门的标识  
如果只想看远程分支可以改为加-r参数 会把本地分支都忽略掉  
***
#### remote新建branch  
这一步倒是简单了 只要上传的分支在远程端不存在 就会立刻创建一个分支 内容与你上传的保持一致  
`git push -u [nickname] [branch_name]`这个命令应该还记得吧  使用此命令上传时写个新的branch_name即可  
***
#### remote切换当前分支  
只要把远程的分支同步到本地即可  
```
git fetch
```
把所有远程的分支同步到本地 其实实质是更新远程仓库的状态 比如说别人往仓库里放了个新branch 这时候不使用fetch的话本地是完全不知道的 甚至branch -a也输出不出来  
接下来老样子checkout就能切换分支了  
当然如果你问的是github如何切换默认分支 我只能说 设置里有  
***
#### remote删除branch  
```
git push -d [nickname] [branch_name]
```
在原来的push命令中加入-d参数可实现分支的删除 注意只会删除远程的分支 本地的是不会受影响的  
***
#### remote重命名  
这个就比较讨厌了 remote分支没有一个简单的改名方法 我们需要好几步操作来实现  
首先看一个好简单的命令  
```
git branch -m [oldname] [newname]
```
看起来很美好 然而这个命令并不会把remote的branch直接改名 而是把它对应的本地分支改名 鉴定为啥用都没有 本地改名还用你教吗  
实际上可以采用上面的命令改名 也可以直接用通用改名方法 总之将想要的名称在本地改出来  
接下来用上面的方法删掉远程分支 删完再传上去改好名的分支 等于兜了个圈子  
这还没完 之前的分支是可能与本地库有关联的 这一波操作直接偷天换日了 现在还要重新关联这个“新”分支与刚上传的重命名的分支    
```
git branch --set-upstream-to [nickname]/[newname]
```
这个语句还有别的形式进行同样操作 用哪种都是可以的  
#### remote merge  
首先说一下传统办法 假设两个要合并的branch一个在本地一个在远程 那么操作过程就是无脑的把远程的拷下来到本地 然后merge 最后push回原本的分支作为更新  
但是github上有图形界面包装的在线merge过程 merge之前还有可视化的差异对比以及冲突排解过程 很难不心动  
因此merge操作都在本地好说 都到远程了也好说 至于实际上用哪个都无所谓了  
github上的merge操作也简单 点开pull request界面 选择两个branch 接下来全是跟着github的界面走就是了   
***
这一QA文档到此就结束了  
合集详见[这里](https://github.com/cre185/QA_for_git)  